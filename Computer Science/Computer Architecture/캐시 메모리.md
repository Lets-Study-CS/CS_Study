# 캐시 메모리(Cache Memory)

## 캐시 메모리 란?
> 속도가 빠른 장치와 느린 장치에서 속도 차이에 따른 **병목 현상**을 줄이기 위한 메모리를 말한다.

**Caching**은 컴퓨터의 처리 성능을 높이기 위한 기법

- ex) CPU 코어와 메모리 사이의 병목 현상 완화
- ex) 웹 브라우저 캐시 파일은, 하드디스크와 웹페이지 사이의 병목 현상을 완화

[](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdiQZBJ%2FbtqzOV4tNYh%2FPcg69y0y9Ez9DVmyY0KIp0%2Fimg.webp)

### CPU와 주기억장치
- CPU가 주기억장치에서 저장된 데이터를 읽어올 때, 자주 사용되는 데이터는 캐시 메모리에 저장, 이에 다시 사용 될 때는 주기억장치가 아닌 캐시 메모리에서 먼저 가져온다.

### 속도 Good, 가격 Bad
- 속도라는 장점을 얻지만, 용량이 적고 비싸다

### 다량의 캐시 메모리
- CPU에는 이러한 캐시 메모리가 2~3개 사용된다. L1~L3로 불리며, L1순으로 빠르게 접근한다.

---

## 캐시 메모리 작동 원리

- 시간 지역성
반복문과 같은 조건 변수처럼 한번 참조된 데이터는 잠시후 또 참조될 가능성이 높다

- 공간 지역성
A[0], A[1]과 같은 연속 접근 시, 참조된 데이터 근처에 있는 데이터가 잠시후 또 사용될 가능성이 높다

- 순차적 지역성
분기가 발생하지 않는 한 명령어는 메모리에 저장된 순서대로 인출/실행 된다.

CPU가 요청한 데이터가 캐시에 있다면 `Cache Hit` 없다면 `Cache Miss`


### 캐시 미스가 나는 경우?
1. Cold miss
    해당 메모리 주소를 처음 불러서 나는 미스

2. Conflict miss
    캐시 메모리에 A와 B 데이터를 저장해야 하는데, A와 B가 같은 캐시 메모리 주소에 할당

3. Capacity miss
    캐시 메모리의 공간이 부족해서 나는 미스

이러한 단점들을 해결하기 위해 캐시 크기를 키운다면, 캐시 접근속도가 느려지고 파워를 많이 잡아 먹는 단점이 생긴다.


### 구동 및 작동 방식
- Direct Mapped Cache
[](https://file.namu.moe/file/8bc9e381797334eb33da66e3ba501be191171b1c5abb113ab52fed45a20084b1c8d2eb5a0ba399d67b38a9d5990b5d5a)

DRAM의 여러 주소가 캐시 메모리의 한 주소에 대응되는 다대일 방식
캐시 메모리는 인덱스 필드 + 태그 필드 + 데이터 필드 로 구성되어 있고, 위같은 경우 동일 인덱스 필드에 매핑

**용어정리**
- 블록 : 데이터의 기본 단위인 워드의 집합
- 데이터 메모리 : 메모리의 데이터들이 저장된 블록으로 구성
- 태그 메모리 : 데이터 메모리의 블록을 탐색할 정보를 포함
    - 태그 : CPU가 요청한 데이터를 탐색하는데 사용할 주소의 일부. 캐시 블록 주소에서 인덱스로 사용되지 않는 부분이다.
    - 유효 비트 : 캐시 블록이 유요한 데이터인지 나타낸다.
    - 갱신 비트 : 캐시로 블록을 가져온 후 CPU가 블록을 수정했는지 나타낸다.

간단하고 빠르나 **Conflict Miss** 가 발생한다. 같은 색깔들의 데이터를 동시 사용 할 시 적용된다.

- Fully Associative Cache

비어있는 캐시 메모리에 마음대로 주소를 저장하는 방식
저장은 편리, 찾을 때는 문제
조건이나 규칙이 없어 특정 캐시 Set 안에 있는 모든 블럭을 한번에 찾아 원하는 데이터가 있는지 검색해야함. CAM 이라는 특수한 메모리 구조를 사용, 가격 매우 비쌈

- Set Associative Cache

Direct + Fully 방식. 특정 행을 지정하고, 그 행안의 어떤 열이든 비어있을 때 저장한다.
Direct에 비해 검색 속도는 느리지만, 저장이 빠르고 Fully에 비해 저장이 느린 대신 검색이 빠른 중간 형.